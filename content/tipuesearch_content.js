var tipuesearch = {"pages": [{'title': 'About', 'text': 'HI!!!! 我是40823144 柯晉瑚 \n My Repository:  https://github.com/40823144/cd2021 \n My Github Pages:  https://40823144.github.io/cd2021/content/index.html', 'tags': '', 'url': 'About.html'}, {'title': 'csave', 'text': '目前的 cmsimde 在編輯器下方新增一個 csave 按鈕, 意即 collabrative save, 當動態網際管理系統在多人同時維護登入維護網頁內容時, 編輯各頁面時段, 該頁面可能已經改版, 因此使用 csave 按鈕存檔時, 會導入當下最新的該頁面內容, 並試圖與編輯中的頁面內容進行合併. \n 使用 csave 按鈕存檔無法刪除頁面資料. \n 使用 Edit All 模式, 無法使用 csave 按鈕（尚未測試). \n', 'tags': '', 'url': 'csave.html'}, {'title': 'CMSiMDE', 'text': '使用 CMSiMDE 建議使用者安裝 flask flask_cors bs4 lxml pelican markdown leo 等模組. 其中的 flask flask_cors bs4 lxml pelican markdown為啟動 CMSiMDE 的必要模組, 而 leo 則是 CMSMDE 開發者所使用的大綱管理工具, 可以用於與 CMSiMDE 整合的 Pelican blog 及 Reveal.js 網際簡報編輯之用. \n 模組安裝指令為: \n pip install flask flask_cors lxml bs4 markdown pelican leo \n \n \n', 'tags': '', 'url': 'CMSiMDE.html'}, {'title': 'W2~W4', 'text': 'W2~W4為兩人一組，進行 協同題目選定討論。 \n stage1-ag17 題目：纜車 動機：因為不想走路 W2:繪製零件 W3:使用Coppeliasim模擬動作並除錯 W4:報告 \n', 'tags': '', 'url': 'W2~W4.html'}, {'title': '組員', 'text': '廖韋博 40823142 \n 倉儲： https://github.com/40823142 \n 網站： https://40823142.github.io/cd2021/content/ \n 負責部分：繪圖 \n 柯晉瑚 40823144 \n 倉儲： https://github.com/40823144 \n 網站： https://40823144.github.io/cd2021/content/ \n 負責部分：CoppeliaSim \n', 'tags': '', 'url': '組員.html'}, {'title': 'W3', 'text': '錯誤1 \n 想要讓輪子在軌道上跑，但是會滑出去。 \n \n 錯誤2 \n 想要把軌道固定住，但是都會掉下來。 \n \n 錯誤3 \n 因為輪子跟固定的物件都在同一個軸，所以下方的纜車也會跟著做旋轉，最後離開軌道。 \n', 'tags': '', 'url': 'W3.html'}, {'title': 'W5~W9', 'text': '題目：四腳獸 \n \n 倉儲： https://github.com/40823144/stage2-ag10 \n 網站： https://40823144.github.io/stage2-ag10/content/index.html \n 簡報： https://40823144.github.io/stage2-ag10/reveal/index.html#/ \n 模擬影片： https://www.youtube.com/watch?v=6aQ9x_dSVAw&list=PL7Ho6OOT1C_Ujluv4oU9TW_a3eumcBpLV \n', 'tags': '', 'url': 'W5~W9.html'}, {'title': '組員：', 'text': '40823142 廖韋博\xa0 40823142_repo \xa0 40823142_site \n 40823144 柯晉瑚\xa0 40823144_repo \xa0 40823144_site \n 40823127 陳佑杰\xa0 40823127_repo \xa0 40823127_site \n 40823148 韋誠昌\xa0 40823148_repo \xa0 40823148_site \n 工作分配 \n 繪圖- 40823127 陳佑杰 \n 模擬- 40823142 廖韋博\xa040823148 韋誠昌 \n 討論資料統整和網站更新- 40823144 柯晉瑚 \n', 'tags': '', 'url': '組員：.html'}, {'title': 'W5', 'text': '打算先做出一隻腳來進行模擬。 \n 初步零件 \n \n plslvs模擬結果 \n \n', 'tags': '', 'url': 'W5.html'}, {'title': 'W6', 'text': '單腳模擬成功，再來嘗試組裝並模擬雙腳運作。 \n \n', 'tags': '', 'url': 'W6.html'}, {'title': 'W7', 'text': '不開碰撞後，雙腳模擬成功，但會有些許干涉，外型跟內部要大改造。 \n \n', 'tags': '', 'url': 'W7.html'}, {'title': 'W8', 'text': '外型大改造並且使四足模擬成功。 \n', 'tags': '', 'url': 'W8.html'}, {'title': '成品：', 'text': 'GD: ttt檔 \n 模擬影片： \n \n 零件圖： \n \n 立體圖： \n', 'tags': '', 'url': '成品：.html'}, {'title': 'W13~W14', 'text': '', 'tags': '', 'url': 'W13~W14.html'}, {'title': 'RoboDK', 'text': '單純的改了一 些數字，讓它可以來回。 \n \n # KMOLab Portable RoboDK pick and place\nfrom robolink import *    # API to communicate with robodk\nfrom robodk import *      # robodk robotics toolbox\n\n# Setup global parameters\nBALL_DIAMETER = 100 # diameter of one ball\nAPPROACH = 100      # approach distance to grab each part, in mm\nnTCPs = 6           # number of TCP\'s in the tool\n\n#----------------------------------------------\n# Function definitions\n\ndef box_calc(BALLS_SIDE=4, BALLS_MAX=None):\n    """Calculate a list of points (ball center) as if the balls were stored in a box"""\n    if BALLS_MAX is None: BALLS_MAX = BALLS_SIDE**3\n    xyz_list = []\n    for h in range(BALLS_SIDE):\n        for i in range(BALLS_SIDE):\n            for j in range(BALLS_SIDE):\n                xyz_list = xyz_list + [[(i+0.5)*BALL_DIAMETER, (j+0.5)*BALL_DIAMETER, (h+0.5)*BALL_DIAMETER]]\n                if len(xyz_list) >= BALLS_MAX:\n                    return xyz_list\n    return xyz_list\n\ndef pyramid_calc(BALLS_SIDE=4):\n    """Calculate a list of points (ball center) as if the balls were place in a pyramid"""\n    #the number of balls can be calculated as: int(BALLS_SIDE*(BALLS_SIDE+1)*(2*BALLS_SIDE+1)/6)\n    BALL_DIAMETER = 100\n    xyz_list = []\n    sqrt2 = 2**(0.5)\n    for h in range(BALLS_SIDE):\n        for i in range(BALLS_SIDE-h):\n            for j in range(BALLS_SIDE-h):\n                height = h*BALL_DIAMETER/sqrt2 + BALL_DIAMETER/2\n                xyz_list = xyz_list + [[i*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, j*BALL_DIAMETER + (h+1)*BALL_DIAMETER*0.5, height]]\n    return xyz_list\n\ndef balls_setup(frame, positions):\n    """Place a list of balls in a reference frame. The reference object (ball) must have been previously copied to the clipboard."""\n    nballs = len(positions)\n    step = 1.0/(nballs - 1)\n    for i in range(nballs):\n        newball = frame.Paste()\n        newball.setName(\'ball \' + str(i)) #set item name\n        newball.setPose(transl(positions[i])) #set item position with respect to parent\n        newball.setVisible(True, False) #make item visible but hide the reference frame\n        newball.Recolor([1-step*i, step*i, 0.2, 1]) #set RGBA color\n\ndef cleanup_balls(parentnodes):\n    """Delete all child items whose name starts with \\"ball\\", from the provided list of parent items."""\n    todelete = []\n    for item in parentnodes:\n        todelete = todelete + item.Childs()\n\n    for item in todelete:\n        if item.Name().startswith(\'ball\'):\n            item.Delete()\n\ndef TCP_On(toolitem, tcp_id):\n    """Attach the closest object to the toolitem Htool pose,\n    furthermore, it will output appropriate function calls on the generated robot program (call to TCP_On)"""\n    toolitem.AttachClosest()\n    toolitem.RDK().RunMessage(\'Set air valve %i on\' % (tcp_id+1))\n    toolitem.RDK().RunProgram(\'TCP_On(%i)\' % (tcp_id+1));\n        \ndef TCP_Off(toolitem, tcp_id, itemleave=0):\n    """Detaches the closest object attached to the toolitem Htool pose,\n    furthermore, it will output appropriate function calls on the generated robot program (call to TCP_Off)"""\n    toolitem.DetachAll(itemleave)\n    toolitem.RDK().RunMessage(\'Set air valve %i off\' % (tcp_id+1))\n    toolitem.RDK().RunProgram(\'TCP_Off(%i)\' % (tcp_id+1));\n\n\n#----------------------------------------------------------\n# The program starts here:\n\n# Any interaction with RoboDK must be done through RDK:\nRDK = Robolink(robodk_path="C:/robodk/bin/RoboDK.exe", robodk_ip=\'127.0.0.1\')\n\n# Turn off automatic rendering (faster)\nRDK.Render(False)\n\n#RDK.Set_Simulation_Speed(500); # set the simulation speed\n\n# Gather required items from the station tree\nrobot = RDK.Item(\'Fanuc M-710iC/50\')\nrobot_tools = robot.Childs()\n#robottool = RDK.Item(\'MainTool\')\nframe1 = RDK.Item(\'Table 1\')\nframe2 = RDK.Item(\'Table 2\')\n\n# Copy a ball as an object (same as CTRL+C)\nballref = RDK.Item(\'reference ball\')\nballref.Copy()\n\n# Run a pre-defined station program (in RoboDK) to replace the two tables\nprog_reset = RDK.Item(\'Replace objects\')\nprog_reset.RunProgram()\n\n# Call custom procedure to remove old objects\ncleanup_balls([frame1, frame2])\n\n# Make a list of positions to place the objects\nframe1_list = pyramid_calc(4)\nframe2_list = pyramid_calc(4)\n\n# Programmatically place the objects with a custom-made procedure\nballs_setup(frame1, frame1_list)\n\n# Delete previously generated tools\nfor tool in robot_tools:\n    if tool.Name().startswith(\'TCP\'):\n        tool.Delete()\n        \n# Calculate tool frames for the suction cup tool of 6 suction cups\nTCP_list = []\nfor i in range(nTCPs):\n    TCPi_pose = transl(0,0,100)*rotz((360/nTCPs)*i*pi/180)*transl(125,0,0)*roty(pi/2)\n    TCPi = robot.AddTool(TCPi_pose, \'TCP %i\' % (i+1))\n    TCP_list.append(TCPi)\n\nTCP_0 = TCP_list[0]\n\n# Turn on automatic rendering\nRDK.Render(True)\n\n# Move balls    \nrobot.setPoseTool(TCP_list[0])\nnballs_frame1 = len(frame1_list)\nnballs_frame2 = len(frame2_list)\nidTake = nballs_frame1 - 1\nidLeave = 0\nidTCP = 0\ntarget_app_frame = transl(2*BALL_DIAMETER, 2*BALL_DIAMETER, 4*BALL_DIAMETER)*roty(pi)*transl(0,0,-APPROACH)\n\nwhile idTake >= 0:\n    # ------------------------------------------------------------------\n    # first priority: grab as many balls as possible\n    # the tool is empty at this point, so take as many balls as possible (up to a maximum of 6 -> nTCPs)\n    ntake = min(nTCPs, idTake + 1)\n\n    # approach to frame 1\n    robot.setPoseFrame(frame1)\n    robot.setPoseTool(TCP_0)\n    robot.MoveJ([0,0,0,0,10,-200])\n    robot.MoveJ(target_app_frame)\n\n    # grab ntake balls from frame 1\n    for i in range(ntake):\n        TCPi = TCP_list[i]\n        robot.setPoseTool(TCPi)\n        # calculate target wrt frame1: rotation about Y is needed since Z and X axis are inverted\n        target = transl(frame1_list[idTake])*roty(pi)*rotx(30*pi/180)\n        target_app = target*transl(0,0,-APPROACH)\n        idTake = idTake - 1        \n        robot.MoveL(target_app)\n        robot.MoveL(target)\n        TCP_On(TCPi, i)\n        robot.MoveL(target_app)\n \n    # ------------------------------------------------------------------\n    # second priority: unload the tool     \n    # approach to frame 2 and place the tool balls into table 2\n    robot.setPoseTool(TCP_0)\n    robot.MoveJ(target_app_frame)\n    robot.MoveJ([0,0,0,0,10,-200])\n    robot.setPoseFrame(frame2)    \n    robot.MoveJ(target_app_frame)\n    for i in range(ntake):\n        TCPi = TCP_list[i]\n        robot.setPoseTool(TCPi)\n        if idLeave > nballs_frame2-1:\n            raise Exception("No room left to place objects in Table 2")\n        \n        # calculate target wrt frame1: rotation of 180 about Y is needed since Z and X axis are inverted\n        target = transl(frame2_list[idLeave])*roty(pi)*rotx(30*pi/180)\n        target_app = target*transl(0,0,-APPROACH)\n        idLeave = idLeave + 1        \n        robot.MoveL(target_app)\n        robot.MoveL(target)\n        TCP_Off(TCPi, i, frame2)\n        robot.MoveL(target_app)\n\n    robot.MoveJ(target_app_frame)\n\n# Move home when the robot finishes\nrobot.MoveJ([0,0,0,0,10,-200])\n\n\n\n# Gather required items from the station tree\nrobot = RDK.Item(\'Fanuc M-710iC/50\')\nrobot_tools = robot.Childs()\n#robottool = RDK.Item(\'MainTool\')\nframe1 = RDK.Item(\'Table 1\')\nframe2 = RDK.Item(\'Table 2\')\n\n\n\n# Call custom procedure to remove old objects\ncleanup_balls([frame1 , frame2])\n\n\n# Make a list of positions to place the objects\nframe1_list = pyramid_calc(4)\nframe2_list = pyramid_calc(4)\n\n# Programmatically place the objects with a custom-made procedure\nballs_setup(frame2, frame2_list)\n\n# Delete previously generated tools\nfor tool in robot_tools:\n    if tool.Name().startswith(\'TCP\'):\n        tool.Delete()\n        \n# Calculate tool frames for the suction cup tool of 6 suction cups\nTCP_list = []\nfor i in range(nTCPs):\n    TCPi_pose = transl(0,0,100)*rotz((360/nTCPs)*i*pi/180)*transl(125,0,0)*roty(pi/2)\n    TCPi = robot.AddTool(TCPi_pose, \'TCP %i\' % (i+1))\n    TCP_list.append(TCPi)\n\nTCP_0 = TCP_list[0]\n\n\n\n# Move balls    \nrobot.setPoseTool(TCP_list[0])\nnballs_frame2 = len(frame2_list)\nnballs_frame1 = len(frame1_list)\nidTake = nballs_frame2 - 1\nidLeave = 0\nidTCP = 0\ntarget_app_frame = transl(2*BALL_DIAMETER, 2*BALL_DIAMETER, 4*BALL_DIAMETER)*roty(pi)*transl(0,0,-APPROACH)\n\nwhile idTake >= 0:\n    # ------------------------------------------------------------------\n    # first priority: grab as many balls as possible\n    # the tool is empty at this point, so take as many balls as possible (up to a maximum of 6 -> nTCPs)\n    ntake = min(nTCPs, idTake + 1)\n\n    # approach to frame 1\n    robot.setPoseFrame(frame2)\n    robot.setPoseTool(TCP_0)\n    robot.MoveJ([0,0,0,0,10,-200])\n    robot.MoveJ(target_app_frame)\n\n    # grab ntake balls from frame 1\n    for i in range(ntake):\n        TCPi = TCP_list[i]\n        robot.setPoseTool(TCPi)\n        # calculate target wrt frame1: rotation about Y is needed since Z and X axis are inverted\n        target = transl(frame2_list[idTake])*roty(pi)*rotx(30*pi/180)\n        target_app = target*transl(0,0,-APPROACH)\n        idTake = idTake - 1        \n        robot.MoveL(target_app)\n        robot.MoveL(target)\n        TCP_On(TCPi, i)\n        robot.MoveL(target_app)\n \n    # ------------------------------------------------------------------\n    # second priority: unload the tool     \n    # approach to frame 2 and place the tool balls into table 2\n    robot.setPoseTool(TCP_0)\n    robot.MoveJ(target_app_frame)\n    robot.MoveJ([0,0,0,0,10,-200])\n    robot.setPoseFrame(frame1)    \n    robot.MoveJ(target_app_frame)\n    for i in range(ntake):\n        TCPi = TCP_list[i]\n        robot.setPoseTool(TCPi)\n        if idLeave > nballs_frame2-1:\n            raise Exception("No room left to place objects in Table 2")\n        \n        # calculate target wrt frame1: rotation of 180 about Y is needed since Z and X axis are inverted\n        target = transl(frame1_list[idLeave])*roty(pi)*rotx(30*pi/180)\n        target_app = target*transl(0,0,-APPROACH)\n        idLeave = idLeave + 1        \n        robot.MoveL(target_app)\n        robot.MoveL(target)\n        TCP_Off(TCPi, i, frame2)\n        robot.MoveL(target_app)\n\n    robot.MoveJ(target_app_frame)\n\n# Move home when the robot finishes\nrobot.MoveJ([0,0,0,0,10,-200])\n \n', 'tags': '', 'url': 'RoboDK.html'}, {'title': 'Task', 'text': '完成老師CD2021中的Task任務。 \n', 'tags': '', 'url': 'Task.html'}, {'title': 'task1', 'text': '參考自40823131的 task1 \n # open file, default is read mode, since txt content no chinese char4\n# no encoding = "UTF-08" is needed\nwith open("stage3_2a.txt") as fh: #打開"stage3_2a.txt檔案並命名為fh\n    # readlines will read into the whole line and put into list format 23\n    # has \\n at the end of each line 13\n    #讀取 fh檔案並當作data\n    data = fh.readlines()\n    #修改錯誤的學號\n    data = [a.replace(\'4823122\',\'40823122\') for a in data]\n    #去除組別空白部分\n    data = [b.replace(\'\\t\\t\\t\\t\',\'\') for b in data]\n\n    #print(data)#印出data\n#print(len(data))\nfor i in range(len(data)):#設i迴圈的次數為data的長度\n    #print(data)\n    group = data[i].rstrip("\\n").split("\\t")#設group為取data的次數i消除\\n並且以\\t分割數列\n\n    #print(group)\n    print(\'<p>\'+group[0]+\' ＿ <a href="https://\'+group[1]+\'.github.io/\'+group[0]+\'">site</a> | <a href="https://github.com/\'+group[1]+\'/\'+group[0]+\'">repo</a></p>\')\n#印出group字串\n \n  \n    for g in range(2,18,2):#設g迴圈的範圍從第3項開始+2到第18項\n        try:#try...except 可跳過讀取不到的資料\n            print(\'<p>\'+group[g]+\'＿site:\'+\'<a href="https://\'+group[g]+\'.github.io/cd2021\'+\'">\'+group[g]+\'</a>\'+\'|repo:\'+\'<a href="https://github.com/\'+group[g]+\'/cd2021\'+\'">\'+group[g]+\'</a></p>\')\n            #印出group字串\n   \n        except:\n            continue#返回迴圈 \n stage3_ag1 ＿  site  |  repo \n 40823131＿site: 40823131 |repo: 40823131 \n a40823112＿site: a40823112 |repo: a40823112 \n 40823123＿site: 40823123 |repo: 40823123 \n 40823145＿site: 40823145 |repo: 40823145 \n 40823136＿site: 40823136 |repo: 40823136 \n 40823109＿site: 40823109 |repo: 40823109 \n 40823116＿site: 40823116 |repo: 40823116 \n 40823108＿site: 40823108 |repo: 40823108 \n stage3_ag2 ＿  site  |  repo \n 40823151＿site: 40823151 |repo: 40823151 \n 40623121＿site: 40623121 |repo: 40623121 \n 40871106＿site: 40871106 |repo: 40871106 \n 40823102＿site: 40823102 |repo: 40823102 \n 40823104＿site: 40823104 |repo: 40823104 \n 40823106＿site: 40823106 |repo: 40823106 \n 40823101＿site: 40823101 |repo: 40823101 \n 40823132＿site: 40823132 |repo: 40823132 \n stage3_ag3 ＿  site  |  repo \n 40823119＿site: 40823119 |repo: 40823119 \n 40823150＿site: 40823150 |repo: 40823150 \n 40823103＿site: 40823103 |repo: 40823103 \n 40823107＿site: 40823107 |repo: 40823107 \n 40523252＿site: 40523252 |repo: 40523252 \n 40823154＿site: 40823154 |repo: 40823154 \n stage3_ag4 ＿  site  |  repo \n 40823142＿site: 40823142 |repo: 40823142 \n 40823144＿site: 40823144 |repo: 40823144 \n 40823127＿site: 40823127 |repo: 40823127 \n 40823148＿site: 40823148 |repo: 40823148 \n 40823121＿site: 40823121 |repo: 40823121 \n 40823135＿site: 40823135 |repo: 40823135 \n 40823114＿site: 40823114 |repo: 40823114 \n 40823146＿site: 40823146 |repo: 40823146 \n stage3_ag5 ＿  site  |  repo \n 40823111＿site: 40823111 |repo: 40823111 \n 40823115＿site: 40823115 |repo: 40823115 \n 40823128＿site: 40823128 |repo: 40823128 \n 40823120＿site: 40823120 |repo: 40823120 \n 40823140＿site: 40823140 |repo: 40823140 \n 40823124＿site: 40823124 |repo: 40823124 \n 40823139＿site: 40823139 |repo: 40823139 \n 40823126＿site: 40823126 |repo: 40823126 \n stage3_ag6 ＿  site  |  repo \n 40823152＿site: 40823152 |repo: 40823152 \n 40823110＿site: 40823110 |repo: 40823110 \n 40823122＿site: 40823122 |repo: 40823122 \n 40823125＿site: 40823125 |repo: 40823125 \n 40823117＿site: 40823117 |repo: 40823117 \n 40823129＿site: 40823129 |repo: 40823129 \n 40823149＿site: 40823149 |repo: 40823149 \n 40823153＿site: 40823153 |repo: 40823153', 'tags': '', 'url': 'task1.html'}, {'title': 'task2', 'text': '參考老師的bubbleRob模板並於Stage2上進行remoteAPI的模擬。 \n \n stage2-ttt檔 \n remoteAPI程式碼 \n import sim as vrep\nimport sys\n# child threaded script: \n#simExtRemoteApiStart(19999)\n \nvrep.simxFinish(-1)\n \nclientID = vrep.simxStart(\'127.0.0.1\', 19999, True, True, 5000, 5)\n \nif clientID!= -1:\n    print("Connected to remote server")\nelse:\n    print(\'Connection not successful\')\n    sys.exit(\'Could not connect\')\n \nerrorCode,Revolute_joint=vrep.simxGetObjectHandle(clientID,\'Revolute_joint\',vrep.simx_opmode_oneshot_wait)\n \n \nif errorCode == -1:\n    print(\'Can not find left or right motor\')\n    sys.exit()\n \nerrorCode=vrep.simxSetJointTargetVelocity(clientID,Revolute_joint,3, vrep.simx_opmode_oneshot_wait) \n', 'tags': '', 'url': 'task2.html'}, {'title': 'W15', 'text': "影片字幕翻譯 \n 翻譯使用自 DeepL \n 1.Inverse kinematics for a 2-joint robot arm using geometry \n \n We saw this simple two-link robot in the previous lecture about forward kinematics. \n 我們在先前關於正向運動學的講座中看到了這個簡單的雙連桿機構。 \n The tooltip pose of the robot is simply described by two numbers, coordinates x and y is relative to the world coordinate system. \n 這個工具軟件構成是由兩個數字簡單描述的，相對於絕對坐標系的x和y。 \n So, the problem here is that given x and y, we want to determine the joined angles, q1 and q2. \n 所以，這裡的問題是當我們給定了x和y，要如呵得出我們想連接的角度，即q1和q2。 \n The solution that we’re going to follow in this particular section is a geometric one. \n 我們在這個特殊部分的解決方案須遵循其中一種幾何學。 \n We’re going to start with a simple piece of construction. \n 我們將從一個簡單的結構開始。 \n We’re going to overlay the red triangle on top of our robot. \n 我們假定將一個紅色的三角形覆蓋於我們的機構上。 \n We know that the end point coordinate is x, y, so the vertical height of the triangle is y, the horizontal width is x. \n 我們知道端點座標為x和y，因此三角形的垂直高度為y，水平寬度為x。 \n And, using Pythagoras theorem, we can write r squared equals x squared plus y squared. \n 並且，利用畢氏定理，我們可得出r的平方 = x的平方 + y的平方。 \n So far, so easy. \n 到目前為止，都很容易。 \n Now, we’re going to look at this triangle highlighted here in red and we want to determine \n the angle alpha. \n 現在我們來看此處用紅色突出顯示的三角形，並且確定出我們想要的角度α 。 \n In order to do that, we need to use the cosine rule. \n 為了做到這點，我們須使用餘弦定理。 \n And, if you’re a little rusty on the cosine rule, here is a bit of a refresher. \n 如果你對餘弦定理有點不熟悉，這裡有一些複習資料。 \n We have an arbitrary triangle. \n 我們這邊有一個任意的三角形。 \n We don’t have any right angles in it and we’re going to label the length of this edge as A and the angle opposite that edge, we’re going to label as little a. \n 三角形中沒有任何直角，我們把這條邊的長度標為A，與這條邊相對的角，我們標記為a。 \n And, we do the same for this edge and this angle, and this edge and this angle. \n 並且我們對另兩邊的邊及角做相同的事。 \n So, all together, the sides are labelled capitals A, B and C, and the angles are labelled little a, little b, and little c. \n 因此，所有的邊都被標記為A,B,C，而角都被標記為a,b,c。 \n So, the cosine rule is simply this relationship here. \n 餘弦定理在這裡便以此種簡單的關係表示。 \n It’s a bit like Pythagoras’ theorem except for this extra term on the end with the cos a in it. \n 它有點類似於畢氏定理，只是在最後多了一個帶cosa的項。 \n Now, let’s apply the cosine rule to the particular triangle we looked at a moment ago. \n 現在，讓我們把餘弦定理用於剛才看到的那個特定三角形上。 \n It’s pretty straightforward to write down this particular relationship. \n 可以很直接地寫下此種特殊關係。 \n We can isolate the term cos alpha which gives us the angle alpha that we’re interested in. \n 我們可以將我們所感興趣的α角求出，需將給定的cos\xa0 α 項分離出來。 \n And, it’s defined in terms of the constant link lengths, A1 and A2 and the position of the end effector, x and y. \n 且它是以恆定的連桿長度A1及A2以及末端執行器位置x與y來定義的。 \n We can write this simple relationship between the angles alpha and q2. \n 我們可以寫出此種於α角和q2之間的簡單關係。 \n And, we know from the shape of the cosine function that cos of q2 must be equal to negative of cos alpha. \n 而且，我們從餘弦函數的形狀得知，cos q2須等於 -cos\xa0 α。 \xa0 \n This time, let’s just write an expression for the cosine of the joined angle q2. \n 這次，讓我們只寫出關於連接角q2的餘弦表達式。 \n Now, we’re going to draw yet another red triangle and we’re going apply some simple trigonometry here. \n 現在，我們要再畫一個紅色三角形，並在這使用一些簡單的三角函數。 \n If we know q2, then we know this length and this length of the red triangle. \n 如果我們知道了q2，那我們便可得紅色三角形中q2的對邊長與鄰邊長。 \n We can write this relationship for the sine of the joined angle q2. \n 我們可以將這種關係寫為連接角q2的正弦。 \n Now, we can consider this bigger triangle whose angle is beta and this side length of this triangle is given here in blue. \n 現在我們可以考慮更大的三角形，其角度為β，這個三角形的邊長用藍色表示。 \n And, the length of the other side of the triangle is this. \n 且此三角形的另一邊長是這樣表示的。 \n So, now we can write an expression for the angle beta in terms of these parameters here. \n 所以，現在我們可以用這些參數來寫出一個β角的表達式。 \n Going back to the red triangle that we drew earlier, we can establish a relationship between q1 and the angle beta. \n 回到稍早前我們畫的紅色三角形，我們可以在q1和β角之間建立一種關係。 \n Introduce yet another angle, this one gamma and we can write a relationship between the angle gamma and the tooltip coordinates x and y. \n 引入另一個角度 γ，我們可寫出γ角和工具軟件座標x和y之間的關係。 \n Now, we can write a simple relationship between the angles that we’ve constructed, gamma and beta and the joined angle we’re interested in which is q1. \n 現在，我們可以用建構出的角度γ,β來寫出γ角和β角與欲求之連接角q1之間的簡單關係。 \n And, the total relationship looks something like this. \n 並且整體關係看起來像這樣。 \n Quite a complex relationship, it gives us the angle of joined one, that’s q1 in terms of the end effector coordinates y and x, and a bunch of constants, a1 and a2, and it’s also a function of the second joint angle, q2. \n 此為相當複雜的一個關係，它提供了第一關節角q1與端點坐標y和x，以及一堆常數a1和a2，並且它也是第二關節角q2的函數。 \n So, let’s summarize what it is that we have derived here. \n 所以，讓我們總結一下在這裡得出的結論為何。 \n We have an expression for the cosine of q2 and we have an expression for q1. \n 我們有一個q2的餘弦表達式，和一個q1表達式。 \n Now, the cosine function is symmetrical about 0. \n 現在，餘弦函數在0時為對稱的 \n So, if we know the value of the cosine of q2, then there are two possible solutions a positive angle and a negative angle. \n 所以，假如我們得知cosq2，那它便會有正角與負角兩種解。 \n We’re going to explicitly choose the positive angle. Which means that I can write this expression here. \n 在這裡明確的選擇正角，這意味著我可以在此處寫這個表達式。 \n And now, we have what we call the inverse kinematic solution for this two-link robot. \n 現在我們有了解決雙連桿機構的逆向運動學函式。 \n We have an expression for the two joined angles, q1 and q2 in terms of the end effector pose x and y, and a bunch of constants. \n 我們有一個對連接角q1和q2的表達式，其與末端執行器構成的x和y和一大堆常數有關。 \n You notice that the two equations are not independent. \n 你會注意到這兩個方程式並不獨立。 \n The equation for q1, in fact, depends on the solution for q2. \n 實際上，q1的方程式取決於q2的解。 \n In this case, q2 is negative and we’re going to write the solution for q2 with a negative sign in front of the inverse cosine. \n 在這種情況下，q2為負，因此我們要在反餘弦前加上負號來寫出q2的解。 \n Now, we need to solve for q1, so we’re going to introduce this particular red triangle, the angle beta that we solved previously, and the angle gamma which is defined in terms of y and x. \n 現在我們要求出q1的解，所以我們要引入這個特定的紅色三角形，並用之前得出的β角以及用y和x定義出的γ角。 \n Now, we write a slightly different relationship between q1, gamma and beta, different to what we had before. \n 現在，我們在q1、γ和β之間寫了一個與之前稍微不同的關係。 \n There’s a change of sign involved. \n 這涉及到符號的變化。 \n Then, we can substitute all that previous equation and come up with this expression for q1. \n 然後將先前所有的方程代入，可得出這個q1的表達式。 \n Again, there is a change of sign here. \n 同樣地，這裡也有一個符號的變化。 \n Previously, this was a negative sign. \n 在之前的式子裡，這裡是負號。 \n And, here in summary form is the solution for the inverse kinematics of our two-link robot when it is in this particular configuration, where q2 is negative. \n 這是我們使用逆向運動學於雙連桿機構在此特定構造下的解，其中q2為負值 \n Let’s compare the two solutions, the case where q2 is positive and the case where q2 is negative. \n 讓我們在q2為正以及q2為負的情況下進行兩種解法的比較。 \n ------------------------------------------------------------------------------------------------------- \n 2. Inverse kinematics for a 2-joint robot arm using algebra \n \n Here we have the same two link robot as we just looked at but this time we're going tosolve it using an analytical approach , that is we're going to rely much more on algebra ,particular linear algebra rather than geometry . \n 這裡我們有一個和剛才一樣的二連桿機構，但這次我們要用分析的方法來解決它，也就是說我們要更加的依靠代數，特別是線性代數而不是幾何。 \n We have an expression E , which is the homogeneous transformation which represents the pose of the robots endefector and we looked at this in the last lecture , we can write the endefector pose as a sequence of elementary homogeneous transformations . \n 我們有一個表達式E，它表示連桿末端執行器姿勢的齊次轉換，我們在上一節課看了這個表達式，我們可以把末端執行器的姿勢寫成基本其次轉換的序列。 \n A rotation by Q1 , a translation along the X direction by A1 , a rotation by Q2 and then a translation in the X direction by A2 . \n 透過旋轉q1，使a1沿x方向平移，透過旋轉q2，使a2沿x方向平移。 \n If I expand this out , multiply all the transformations together , I get the expression shown here ; a three by three homogeneous transformation matrix representing the pose of the robot's endefector. \n 如果我將其展開，把所有轉換式乘在一起，我得到的表達式如圖所示；一個3x3的齊次轉換矩陣，它代表著末端執行器的姿勢。 \n Now for this particular two link robot , we are only interested in the position of its endefector , it's X and Y co - ordinate and they are these two elements within the homogeneous transformation matrix , so I'm going to copy those out . \n 現在，對於這個特定的二連桿機構，我們只關注其端點位置，就是其x和y的座標，它們是齊次轉換矩陣中的兩個元素，所以我要將它們複製出來。 \n So here again is our expression for X and Y and what we're going to do is a fairly common trick , we're going to square and add these two equations and I get a relationship that looks like this . \n 所以這裡又是我們x和y的表達式，我們要做一個相當常見的技巧，我們要將這兩個方程平方相加，然後我會得到看起來像這樣的關係式。 \n Now I can solve for the joint angle Q2 in terms of the endefector pose X and Y and the robot's constants A1 and A2. \n 現在我可以根據端點位置x和y及機構的常數a1和a2為條件列式求解關節角度q2。 \n Now what I'm going to do is apply the sum of angles identity . \n 現在我要應用的是角之和的特性。 \n I'm going to expand these terms, sine of Q1 plus Q2 or cos of Q1 plus Q2 and to make life a little bit easier, I'm going to make some substations, so where ever I had cos Q2, I'm going to write C2 and where ever I had sine Q2, I'm going to write S2. \n 我將這些項展開，q1加q2的正弦或q1加q2的餘弦，為了讓式子更容易一些，我將做一些變化，所以在我有cosq2的地方，換寫上C2，在有sinq2的地方，換寫上S2。 \n It's a fairly common shorthand when people are looking at robot kinematic equations. \n 這是一個當人們看到機器運動學方程式的時候，相當常見的速記法。 \n And here are the equations after making those substitutions. \n 下面是進行這些替換後的方程式。 \n Looking at these two equations, I can see that they fall into a very well known form and for that form there is a very well known solution. \n 觀察這兩個方程，我們可以發現它們屬於一個非常知名的形式，對於這個形式有一個非常知名的解決方案。 \n So I'm going to consider just one of the equations, the equation for Y and using our well known identity and it's solution, I can determine the values for the variables little a, little b and little c and once l've determined those, then I can just write down the solution for Q1, which x is the equivalent of theta in this particular case. \n 所以我只考慮其中一個方程，即y的方程，利用我們眾所皆知的特性和它的解，我可以確定變量a,b,c的值，一但我確定了這些值，那麼我就可以寫出q1的解，在這個特定情況下，x相當於θ的值。 \n Here again is our expression for Q1, copied over from the previous slide and we may remember from earlier in our workings that we determined this particular relationship; X squared plus Y squared is equal to this particular complex expression. \n 這裡又是我們對q1的表達式，從上一張幻燈片複製過來的，我們可能還記得在早期的說明中，確定了這種特殊的關係，x的平方加上y的平方等於這個特殊的複合表達式。 \n So I can substitute that in and do some simplification and I end up with this slightly less complex expression for Q1. \n 因此，我可以將其帶入並做一些簡化，最後得到這個比較不那麼複雜的表達式q1。 \n And it is the same expression that I got following the geometric approach in the previous section. \n 而這也是我在上一節中按照幾何方法所得到的表達式。", 'tags': '', 'url': 'W15.html'}, {'title': 'W16', 'text': 'MTB_robot 的取放方塊流程規劃 \n 1. Onshape 零組件繪製 (20%) \n Onshape \n 2. 建立 CoppeliaSim 4.1.0 MTB robot 場景 (20%) \n 雲端_Google drive \n 3. 手臂末端加入 components-gripper-suction pad 吸盤 (20%) \n \n 4. 逆向運動學函式 (20%) \n 程式迴圈控制 \n \n 程式碼 \n function moving(x,y)\n    a=0.400 \n    b=0.400\n    c=math.pow(math.pow(x,2)+math.pow(y,2),0.5)\n    s=(a+b+c)/2\n    area=math.pow((s*(s-a)*(s-b)*(s-c)),0.5)\n    h=area/(2*c)\n    deg1_base=math.atan(x/y)\n    if x<0 and y<0 then\n        deg1_base=deg1_base+math.pi\n    end\n    deg1_tri=math.asin(h/a)\n    deg1=deg1_base+deg1_tri\n    deg2=math.pi-(0.5*math.pi-deg1_tri)-math.acos(h/b)\n    deg3=deg2-deg1\n    sim.setJointTargetPosition(joint01,deg1)\n    sim.setJointTargetPosition(joint02,-deg2)\n    sim.setJointTargetPosition(joint03,deg3)\n    \nend\n\nfunction sysCall_threadmain()\n    joint01=sim.getObjectHandle(\'joint1\')\n    joint02=sim.getObjectHandle(\'joint2\')\n    joint03=sim.getObjectHandle(\'joint3\')\n    jointz=sim.getObjectHandle(\'jointz\')\n    sim.setJointTargetPosition(joint01,0)\n    sim.setJointTargetPosition(joint02,0)\n    sim.setJointTargetPosition(joint03,0)\n    sim.setJointTargetPosition(jointz,0)\n    sim.setIntegerSignal("pad_switch",1)\n    sim.setJointTargetPosition(jointz,-0.03)\n    sim.wait(2)\n    sim.setJointTargetPosition(jointz,0)\n     while sim.getSimulationState()~=sim.simulation_advancing_abouttostopre do\n        moving(0.03,0.7)\n        sim.wait(2)\n        sim.setIntegerSignal("pad_switch",0)\n        sim.wait(2)\n        sim.setIntegerSignal("pad_switch",1)\n        sim.setJointTargetPosition(jointz,-0.03)\n        sim.wait(2)\n        sim.setJointTargetPosition(jointz,0)\n        sim.wait(2)\n        moving(-0.3,-0.55)\n        sim.wait(2)\n        sim.setIntegerSignal("pad_switch",0)\n        sim.wait(2)\n        sim.setIntegerSignal("pad_switch",1)\n        sim.setJointTargetPosition(jointz,-0.03)\n        sim.wait(2)\n        sim.setJointTargetPosition(jointz,0)\n        sim.wait(2)\n        moving(0.1,0.55)\n        sim.wait(2)\n        sim.setIntegerSignal("pad_switch",0)\n        sim.wait(2)\n        sim.setIntegerSignal("pad_switch",1)\n        sim.setJointTargetPosition(jointz,-0.03)\n        sim.wait(2)\n        sim.setJointTargetPosition(jointz,0)\n        sim.wait(2)\n        moving(0,0.8)\n        sim.wait(2)\n        sim.setIntegerSignal("pad_switch",0)\n        sim.wait(2)\n        sim.setIntegerSignal("pad_switch",1)\n        sim.setJointTargetPosition(jointz,-0.03)\n        sim.wait(2)\n        sim.setJointTargetPosition(jointz,0)\n        sim.wait(2)\n    end\nend \n 鍵盤控制 \n \n 程式碼 \n function sysCall_init()\n    joint1=sim.getObjectHandle(\'joint1\')\n    joint2=sim.getObjectHandle(\'joint2\')\n    joint3=sim.getObjectHandle(\'joint3\')\n    jointz=sim.getObjectHandle(\'jointz\')\n    sim.setJointTargetPosition(joint1,0)\n    sim.setJointTargetPosition(joint2,0)\n    sim.setJointTargetPosition(joint3,0)\n    sim.setJointTargetPosition(jointz,0)\n    deg1=0\n    deg2=0\n    deg3=0\nend\n\nfunction sysCall_actuation()\n    message,auxiliaryData=sim.getSimulatorMessage()\n    while message~=-1 do\n        if (message==sim.message_keypress) then\n            if (auxiliaryData[1]==97) then\n            deg1=deg1+1\n            deg3=deg2-deg1\n            sim.setJointTargetPosition(joint1,deg1*math.pi/180)\n            end\n            if (auxiliaryData[1]==100) then\n            deg1=deg1-1\n            deg3=deg2-deg1\n            sim.setJointTargetPosition(joint1,deg1*math.pi/180)\n            end\n            if (auxiliaryData[1]==119) then\n            deg2=deg2+1\n            deg3=deg1-deg2\n            sim.setJointTargetPosition(joint2,deg2*math.pi/180)\n            end\n            if (auxiliaryData[1]==115) then\n            deg2=deg2-1\n            deg3=deg1-deg2\n            sim.setJointTargetPosition(joint2,deg2*math.pi/180)\n            end\n            if (auxiliaryData[1]==2008) then\n                sim.setJointTargetPosition(jointz,-0.03)\n                sim.setIntegerSignal("pad_switch",1)\n            end\n            if(auxiliaryData[1]==2007) then\n                sim.setJointTargetPosition(jointz,0)\n            end\n            if(auxiliaryData[1]==32) then\n                sim.setIntegerSignal("pad_switch",0)\n            end\n            sim.setJointTargetPosition(joint3,deg3*math.pi/180)\n        end\n    message,auxiliaryData=sim.getSimulatorMessage()\n    end\nend\n\nfunction sysCall_sensing()\n    -- put your sensing code here\nend\n\nfunction sysCall_cleanup()\n    -- do some clean-up here\nend\n\n-- See the user manual or the available code snippets for additional callback functions and details\n \n 5. Python remote API 逆向運動學函式 (20%) \n \n 程式碼 \n import sim as vrep\nimport math\nimport random\nimport time\nimport math\n\ndef moving(x,y):\n    a=0.400\n    b=0.400\n    c=math.pow(math.pow(x,2)+math.pow(y,2),0.5)\n    s=(a+b+c)/2\n    area=math.pow((s*(s-a)*(s-b)*(s-c)),0.5)\n    h=area/(2*c)\n    deg1_base=math.atan(x/y)\n    if x<0 and y<0 :\n        deg1_base=deg1_base+math.pi\n    deg1_tri=math.asin(h/a)\n    deg1=deg1_base+deg1_tri\n    deg2=math.pi-(0.5*math.pi-deg1_tri)-math.acos(h/b)\n    deg3=deg2-deg1\n    vrep.simxSetJointTargetPosition(clientID,joint01, deg1,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint02, -deg2,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint03, deg3,opmode)\n\n\nprint(\'start\')\n\nvrep.simxFinish(-1)\n \nclientID = vrep.simxStart(\'127.0.0.1\', 19999, True, True, 5000, 5)\n \nif clientID!= -1:\n    print("Connected to remote API server")\n    \n    res=vrep.simxAddStatusbarMessage(\n        clientID,"40823144",\n        vrep.simx_opmode_oneshot)\n    if res not in (vrep.simx_return_ok,vrep.simx_return_novalue_flag):\n        print("could not add a message to the status bar.")\n        \n        \n    opmode=vrep.simx_opmode_oneshot_wait\n    STREAMING=vrep.simx_opmode_streaming\n    \n    vrep.simxStartSimulation(clientID,opmode)\n    ret,joint01=vrep.simxGetObjectHandle(clientID,"joint1",opmode)\n    ret,joint02=vrep.simxGetObjectHandle(clientID,"joint2",opmode)\n    ret,joint03=vrep.simxGetObjectHandle(clientID,"joint3",opmode)\n    ret,jointz=vrep.simxGetObjectHandle(clientID,"jointz",opmode)\n    \n    vrep.simxSetJointTargetPosition(clientID,joint01,0,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint02,0,opmode)\n    vrep.simxSetJointTargetPosition(clientID,joint03,0,opmode)\n    vrep.simxSetIntegerSignal(clientID,"pad_switch",1,opmode)\n    vrep.simxSetJointTargetPosition(clientID,jointz,-0.03,opmode)\n    time.sleep(1)\n    vrep.simxSetJointTargetPosition(clientID,jointz,0,opmode)\n    while True:\n        moving(0.2,0.7)\n        time.sleep(1)\n        vrep.simxSetIntegerSignal(clientID,"pad_switch",0,opmode)\n        time.sleep(1)\n        vrep.simxSetIntegerSignal(clientID,"pad_switch",1,opmode)\n        vrep.simxSetJointTargetPosition(clientID,jointz,-0.03,opmode)\n        time.sleep(1)\n        vrep.simxSetJointTargetPosition(clientID,jointz,0,opmode)\n        moving(-0.3,-0.55)\n        time.sleep(1)\n        vrep.simxSetIntegerSignal(clientID,"pad_switch",0,opmode)\n        time.sleep(1)\n        vrep.simxSetIntegerSignal(clientID,"pad_switch",1,opmode)\n        vrep.simxSetJointTargetPosition(clientID,jointz,-0.03,opmode)\n        time.sleep(1)\n        vrep.simxSetJointTargetPosition(clientID,jointz,0,opmode) \n', 'tags': '', 'url': 'W16.html'}, {'title': 'Stage3-ag4', 'text': '題目依照Stage2繼續製作，期望它能站立行走，並可鍵盤控制。 \n', 'tags': '', 'url': 'Stage3-ag4.html'}, {'title': '更改1', 'text': '覺得四隻腳支點不夠站不起來，故仿造老師的jansen_walker設計為8隻腳。 \n \n 8腳模擬 \n \n', 'tags': '', 'url': '更改1.html'}, {'title': '模擬問題', 'text': '經過多次測試後仍然站不起來的模擬影片集中處 \n 影片1 \n \n 影片2 \n', 'tags': '', 'url': '模擬問題.html'}, {'title': '英文學習中', 'text': 'API =\xa0Application Programming Interface\xa0應用程式介面 \n simulator 模擬器 \n hierarchy 層次結構 \n components 部件 \n assume 假設 \n programming 程式設計 \n rotation 旋轉 \n orientation 方向 \n reference 參考 \n typically 通常情況下 \n establish 建立 \n serial 串行 \n structurs 結構 \n geometries 幾何圖形 \n collision 碰撞 \n', 'tags': '', 'url': '英文學習中.html'}, {'title': 'CoppeliaSim', 'text': '深知自己對CoppeliaSim的不熟悉故開始學習 \n 學習處 \n 進度 6/77 \n joint介紹 \n 依照框的顏色為 \n 黑：旋轉軸 \n 紅 ：稜形軸 \n 藍 ：球形軸 \n 一個軸只能接一個實體，但一個實體可以接很多個軸。 \n', 'tags': '', 'url': 'CoppeliaSim.html'}, {'title': 'ssh', 'text': '製作鑰匙的指令 \n ssh-keygen -t rsa -b 4096 -C  "使用者學號" \n \n 把製作好的 id_rsa 與 id_rsa.pub 利用 puttygen 轉換成 private key 與 public key \n \n \n \n 修改start.bat的設定 \n \n 將id_sra上的密碼丟到github setting裡的創建new sshkey \n \n 修改Y:\\tmp\\cad2020\\.git裡的config設定 \n \n 到putty.exe的session設定github.com \n \n 設定Proxy (隨身系統可不用 \n 設定SSH裡的Auth讀取鑰匙.ppk的位置 \n \n 之後便可以不輸入帳號密碼進行git push \n \n', 'tags': '', 'url': 'ssh.html'}, {'title': 'heroku', 'text': '步驟1.進入 https://heroku.com 建立帳號。 \n 步驟2.建立heroku app。 \n 步驟3.下載 Heroku CLI。 \n 步驟4.修改start.bat裡的命令搜尋路徑，令heroku可在命令視窗執行。 \n \n \n 步驟5.測試是否可執行及推送。 \n \n \n \n', 'tags': '', 'url': 'heroku.html'}, {'title': 'DC推廣中心', 'text': '官方網址： https://discord.com/ \n 全名為Discord， 是一款專為社群設計的免費網路即時通話軟體與數位發行平台。 \n \n 因為目前疫情爆發的緣故，所以準備了除了Google meeting以外的通訊軟體以備不時之需。', 'tags': '', 'url': 'DC推廣中心.html'}]};